# 第二章 Spring AOP 基础  

## 2.1 @AspectJ 注解驱动  

• 激活 @AspectJ 模块
		• 注解激活 - @EnableAspectJAutoProxy
		• XML 配置 - <aop:aspectj-autoproxy/>
• 声明 Aspect
		• @Aspect  



（1）主程序：**AspectJAnnotationDemo**，**使用注解的方式**

```java
@Aspect        // 声明为 Aspect 切面
@Configuration // Configuration class
@EnableAspectJAutoProxy // 激活 Aspect 注解自动代理
public class AspectJAnnotationDemo {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.register(AspectJAnnotationDemo.class);
        context.refresh();

        AspectJAnnotationDemo aspectJAnnotationDemo = context.getBean(AspectJAnnotationDemo.class);

        context.close();
    }
}
```



（2）**xml方式**

主程序：AspectJXmlDemo

**建立spring-aop-context.xml文件**



## 2.2 编程方式创建 @AspectJ 代理  

实现类
• org.springframework.aop.aspectj.annotation.AspectJProxyFactory  



主程序：

AspectJAnnotationUsingAPIDemo

AspectConfiguration

```java
public class AspectJAnnotationUsingAPIDemo {

    public static void main(String[] args) {

        // 通过创建一个 HashMap 缓存，作为被代理对象
        Map<String, Object> cache = new HashMap<>();
        // 创建 Proxy 工厂(AspectJ)
        AspectJProxyFactory proxyFactory = new AspectJProxyFactory(cache);
        // 增加 Aspect 配置类
        proxyFactory.addAspect(AspectConfiguration.class);

        proxyFactory.addAdvice(new MethodBeforeAdvice() {
            @Override
            public void before(Method method, Object[] args, Object target) throws Throwable {
                if ("put".equals(method.getName()) && args.length == 2) {
                    System.out.printf("[MethodBeforeAdvice] 当前存放是 Key: %s , Value : %s \n", args[0], args[1]);
                }
            }
        });

        // 存储数据
        // cache.put("1", "A");
        // 通过代理对象存储数据
        Map<String, Object> proxy = proxyFactory.getProxy();
        proxy.put("1", "A");
        proxy.put("1", "B");
        System.out.println(cache.get("1"));

    }
}
```



## 2.3 XML 配置驱动 - 创建 AOP 代理  

实现方法
• 配置 org.springframework.aop.framework.ProxyFactoryBean
• Spring Schema-Based 配置
• <aop:config>
• <aop:aspectj-autoproxy/>  



（1）编写spring-aop-context.xml文件

```xml
<bean id="echoService" class="org.geekbang.thinking.in.spring.aop.overview.DefaultEchoService"/>

<bean id="echoServiceProxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="targetName" value="echoService"/>
</bean>
```



（2）主程序：ProxyFactoryBeanDemo



（3）配置拦截器：EchoServiceMethodInterceptor，同时在xml文件中加入相应的bean

```xml
<bean id="echoServiceMethodInterceptor"
      class="org.geekbang.thinking.in.spring.aop.features.interceptor.EchoServiceMethodInterceptor"/>


<bean id="echoServiceProxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="targetName" value="echoService"/>
        <property name="interceptorNames">
            <value>echoServiceMethodInterceptor</value>
        </property>
    </bean>
```



## 2.4 标准代理工厂 API  

实现类 - org.springframework.aop.framework.ProxyFactory  

主程序：ProxyFactoryDemo



注意ProxyFactory和ProxyFactoryBean的区别



## 2.5 @AspectJ Pointcut 指令与表达式  

主程序：

（1）AspectJAnnotatedPointcutDemo

（2）AspectConfiguration





## 2.6 XML 配置 Pointcut  

XML 配置
• <aop:pointcut />  



主程序：

（1）AspectJSchemaBasedPointcutDemo

（2）spring-aop-context.xml文件的配置

（3）AspectXmlConfig



```xml
<aop:aspectj-autoproxy/>

<bean id="aspectXmlConfig" class="org.geekbang.thinking.in.spring.aop.features.aspect.AspectXmlConfig"/>

<aop:config>
    <aop:aspect id="AspectXmlConfig" ref="aspectXmlConfig">
        <aop:pointcut id="anyPublicMethod" expression="execution(public * *(..))"/>
        <aop:before method="beforeAnyPublicMethod" pointcut-ref="anyPublicMethod"/>
    </aop:aspect>
</aop:config>
```

```java
public class AspectJSchemaBasedPointcutDemo {

    public static void main(String[] args) {
        ClassPathXmlApplicationContext context =
                new ClassPathXmlApplicationContext("classpath:/META-INF/spring-aop-context.xml");

        context.refresh();

        EchoService echoService = context.getBean("echoService", EchoService.class);

        System.out.println(echoService.echo("Hello,World"));

        context.close();
    }
```

```java
public class AspectXmlConfig {
    
    public void beforeAnyPublicMethod() {
        System.out.println("@Before any public method.");
    }
}
```





## 2.7 API 实现 Pointcut  

• 核心 API - org.springframework.aop.Pointcut
		• org.springframework.aop.ClassFilter
		• org.springframework.aop.MethodMatcher
• 适配实现 - DefaultPointcutAdvisor  



源码：

Pointcut和StaticMethodMatcherPointcut

主程序：

（1）EchoServicePointcut

（2）PointcutAPIDemo



```java
public class EchoServicePointcut extends StaticMethodMatcherPointcut {

    private String methodName;

    private Class targetClass;

    public EchoServicePointcut(String methodName, Class targetClass) {
        this.methodName = methodName;
        this.targetClass = targetClass;
    }

    @Override
    public boolean matches(Method method, Class<?> targetClass) {
        return Objects.equals(methodName, method.getName())
                && this.targetClass.isAssignableFrom(targetClass);
    }

    public String getMethodName() {
        return methodName;
    }

    public void setMethodName(String methodName) {
        this.methodName = methodName;
    }

    public Class getTargetClass() {
        return targetClass;
    }

    public void setTargetClass(Class targetClass) {
        this.targetClass = targetClass;
    }
}
```

```java
public class PointcutAPIDemo {

    public static void main(String[] args) {

        EchoServicePointcut pointcut = new EchoServicePointcut("echo", EchoService.class);

        // 将 Pointcut 适配成 Advisor

        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, new EchoServiceMethodInterceptor());

        DefaultEchoService defaultEchoService = new DefaultEchoService();
        ProxyFactory proxyFactory = new ProxyFactory(defaultEchoService);
        // 添加 Advisor
        proxyFactory.addAdvisor(advisor);

        // 获取代理对象
        EchoService echoService = (EchoService) proxyFactory.getProxy();
        System.out.println(echoService.echo("Hello,World"));
    }
}
```



## 2.8 @AspectJ 拦截动作  

注解 - @Around
• 与 @Pointcut 有什么区别？  

（1）AspectConfiguration

```java
@Around("anyPublicMethod()")         // Join Point 拦截动作
public void aroundAnyPublicMethod(){
    System.out.println("@Around any public method.");
}
```

（2）执行程序AspectJAnnotatedPointcutDemo

发现：before和execute都不会执行。

 此时，修改

```java
@Around("anyPublicMethod()")         // Join Point 拦截动作
public Object aroundAnyPublicMethod(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println("@Around any public method.");
    return pjp.proceed();
}
```

发现：execute、around和before都会执行



区别：

before：不需要去显示去触发目标方法执行

around：需要去显示去触发目标方法执行































































































