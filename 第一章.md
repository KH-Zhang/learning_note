# 第一章 Spring AOP 总览  

## 1.1 Java基础

- Java ClassLoading  

主程序：ClassLoadingDemo



## 1.2 AOP引入

 Java OOP 存在哪些局限性？
• 静态化语言： 类结构一旦定义， 不容易被修改
• 侵入性扩展： 通过继承和组合组织新的类结构  



## 1.3 AOP相关概念

参考：

[Spring AOP概念Aspect、Advice、JoinPoint、JoinCut与Execution_Anur IjuoKaruKas的博客-CSDN博客](https://blog.csdn.net/anurnomeru/article/details/79798659#:~:text=关于join point 和 point cut 的区别 在 Spring,Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西.)

[Spring AOP 重要概念以及理解_爱健身的小刘-CSDN博客](https://blog.csdn.net/liuyishan1993/article/details/79367697)

[Spring AOP之坑：完全搞清楚advice的执行顺序_洛丹伦的夏天-CSDN博客_aop执行顺序](https://blog.csdn.net/qq_32331073/article/details/80596084?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link)

## 1.4 AOP代理

**静态代理**

```java
public class ProxyEchoService implements EchoService {

    private final EchoService echoService;

    public ProxyEchoService(EchoService echoService) {
        this.echoService = echoService;
    }

    @Override
    public String echo(String message) {
        long startTime = System.currentTimeMillis();
        String result = echoService.echo(message);
        long costTime = System.currentTimeMillis() - startTime;
        System.out.println("echo 方法执行的实现：" + costTime + " ms.");
        return result;
    }
}
```

```java
public class StaticProxyDemo {

    public static void main(String[] args) {
        EchoService echoService = new ProxyEchoService(new DefaultEchoService());
        echoService.echo("Hello,World");
    }
}
```



静态代理原理参考：

[Java - 静态代理详讲 - StanleyBlogs - 博客园 (cnblogs.com)](https://www.cnblogs.com/StanleyBlogs/p/10761604.html)



**动态代理**

源代码：JdkDynamicProxyDemo



动态代理和静态代理的区别:

动态代理是全新生成的一个字节码的类



## 1.5 Java AOP 判断模式

判断来源
	• 类型（ Class）
	• 方法（ Method）
	• 注解（ Annotation）
	• 参数（ Parameter）
	• 异常（ Exception）  

AOP目标过滤，主程序：TargetFilterDemo

通过Spring的API进行判断拦截

```Java
public class TargetFilterDemo {

    public static void main(String[] args) throws ClassNotFoundException {
        String targetClassName = "org.geekbang.thinking.in.spring.aop.overview.EchoService";
        // 获取当前线程 ClassLoader
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        // 获取目标类
        Class<?> targetClass = classLoader.loadClass(targetClassName);
        // 方法定义：String echo(String message);
        // Spring 反射工具类
        Method targetMethod = ReflectionUtils.findMethod(targetClass, "echo", String.class);
        System.out.println(targetMethod);

        // 查找方法  throws 类型为 NullPointerException
        ReflectionUtils.doWithMethods(targetClass, new ReflectionUtils.MethodCallback() {
            @Override
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                System.out.println("仅抛出 NullPointerException 方法为：" + method);
            }
        }, new ReflectionUtils.MethodFilter() {
            @Override
            public boolean matches(Method method) {
                Class[] parameterTypes = method.getParameterTypes();
                Class[] exceptionTypes = method.getExceptionTypes();
                return parameterTypes.length == 1
                        && String.class.equals(parameterTypes[0])
                        && exceptionTypes.length == 1
                        && NullPointerException.class.equals(exceptionTypes[0]);
            }
        });
    }
}
```



## 1.6 Java AOP 拦截器模式（ Interceptor）  

拦截类型
	• 前置拦截（ Before）
	• 后置拦截（ After）
	• 异常拦截（ Exception）  



主程序：AopInterceptorDemo

```java
public class AopInterceptorDemo {

    public static void main(String[] args) {
        // 前置模式 + 后置模式
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        Object proxy = Proxy.newProxyInstance(classLoader, new Class[]{EchoService.class}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                if (EchoService.class.isAssignableFrom(method.getDeclaringClass())) {
                    // 前置拦截器
                    BeforeInterceptor beforeInterceptor = new BeforeInterceptor() {
                        @Override
                        public Object before(Object proxy, Method method, Object[] args) {
                            return System.currentTimeMillis();
                        }
                    };
                    Long startTime = 0L;
                    Long endTime = 0L;
                    Object result = null;
                    try {
                        // 前置拦截
                        startTime = (Long) beforeInterceptor.before(proxy, method, args);
                        EchoService echoService = new DefaultEchoService();
                        result = echoService.echo((String) args[0]); // 目标对象执行
                        // 方法执行后置拦截器
                        AfterReturnInterceptor afterReturnInterceptor = new AfterReturnInterceptor() {
                            @Override
                            public Object after(Object proxy, Method method, Object[] args, Object returnResult) {
                                return System.currentTimeMillis();
                            }
                        };
                        // 执行 after
                        endTime = (Long) afterReturnInterceptor.after(proxy, method, args, result);
                    } catch (Exception e) {
                        // 异常拦截器（处理方法执行后）
                        ExceptionInterceptor interceptor = (proxy1, method1, args1, throwable) -> {
                        };
                    } finally {
                        // finally 后置拦截器
                        FinallyInterceptor interceptor = new TimeFinallyInterceptor(startTime, endTime);
                        Long costTime = (Long) interceptor.finalize(proxy, method, args, result);
                        System.out.println("echo 方法执行的实现：" + costTime + " ms.");
                    }

                }
                return null;
            }
        });

        EchoService echoService = (EchoService) proxy;
        echoService.echo("Hello,World");
    }
}

class TimeFinallyInterceptor implements FinallyInterceptor {

    private final Long startTime;

    private final Long endTime;

    TimeFinallyInterceptor(Long startTime, Long endTime) {
        this.startTime = startTime;
        this.endTime = endTime;
    }

    @Override
    public Object finalize(Object proxy, Method method, Object[] args, Object returnResult) {
        // 方法执行时间（毫秒）
        Long costTime = endTime - startTime;
        return costTime;
    }
}
```



## 1.7 Spring AOP 功能概述  

核心特性
• 纯 Java 实现、 无编译时特殊处理、 不修改和控制 ClassLoader
• 仅支持方法级别的 Join Points
• 非完整 AOP 实现框架
• Spring IoC 容器整合
• AspectJ 注解驱动整合（ 非竞争关系）  



## 1.8 Spring AOP 编程模型  

注解驱动
• 实现： Enable 模块驱动， @EnableAspectJAutoProxy
• 注解：
		• 激活 AspectJ 自动代理： @EnableAspectJAutoProxy
		• Aspect ： @Aspect
		• Pointcut ： @Pointcut
		• Advice ： @Before、 @AfterReturning、 @AfterThrowing、 @After、 @Around
		• Introduction ： @DeclareParents  



![image-20211008195103166](C:\Users\KeHe\AppData\Roaming\Typora\typora-user-images\image-20211008195103166.png)



底层 API
• 实现： JDK 动态代理、 CGLIB 以及 AspectJ
• API：
• 代理： AopProxy
• 配置： ProxyConfig
• Join Point： JoinPoint
• Pointcut ： Pointcut
• Advice ： Advice、 BeforeAdvice、 AfterAdvice、 AfterReturningAdvice、
ThrowsAdvice  



## 1.9 Spring AOP Advice 类型  

Advice 类型
• 环绕（ Around）
• 前置（ Before）
• 后置（ After）
• 方法执行
• finally 执行
• 异常（ Exception）  



**AOP代理实现**

• JDK 动态代理实现 - 基于接口代理 ：JdkDynamicAopProxy，Proxy#newProxyInstance
• CGLIB 动态代理实现 - 基于类代理（ 字节码提升）：CglibAopProxy
• AspectJ 适配实现  ：AspectJProxyFactory



## 1.10 JDK 动态代理  

为什么 Proxy.newProxyInstance 会生成新的字节码？  

主程序：JdkDynamicProxyDemo

Proxy#newProxyInstance

```java
// class $Proxy0 extends java.lang.reflect.Proxy implements EchoService {
//   $Proxy0(InvocationHandler handler){
//      super(handler);
//   }
// }
```



## 1.11 CGLIB 动态代理  

主程序：CglibDynamicProxyDemo

**为什么 Java 动态代理无法满足 AOP 的需要？（需要重新学习讨论）**  

```java
public class CglibDynamicProxyDemo {

    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        // 指定 super class = DefaultEchoService.class
        Class<?> superClass = DefaultEchoService.class;
        enhancer.setSuperclass(superClass);
        // 指定拦截接口
        enhancer.setInterfaces(new Class[]{EchoService.class});

        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object source, Method method, Object[] args,
                                    MethodProxy methodProxy) throws Throwable {
                long startTime = System.currentTimeMillis();
                // Source -> CGLIB 子类
                // 目标类  -> DefaultEchoService
                // 错误使用
//                Object result = method.invoke(source, args);
                // 正确的方法调用
                Object result = methodProxy.invokeSuper(source, args);
                long costTime = System.currentTimeMillis() - startTime;
                System.out.println("[CGLIB 字节码提升] echo 方法执行的实现：" + costTime + " ms.");
                return result;
            }
        });

        // 创建代理对象
        EchoService echoService = (EchoService) enhancer.create();
        // 输出执行结果
        System.out.println(echoService.echo("Hello,World"));
    }
}
```



## 1.12 AspectJ 注解驱动    

AspectJ 注解
• 激活 AspectJ 自动代理： @EnableAspectJAutoProxy
• Aspect ： @Aspect
• Pointcut ： @Pointcut
• Advice ： @Before、 @AfterReturning、 @AfterThrowing、 @After、 @Around
• Introduction ： @DeclareParents  



• 问： Spring AOP 和 AspectJ AOP 存在哪些区别？
• 答：
• AspectJ 是 _x0008_AOP 完整实现， Spring AOP 则是部分实现
• Spring AOP 比 AspectJ 使用更简单
• Spring AOP 整合 AspectJ 注解与 Spring IoC 容器
• Spring AOP 仅支持基于代理模式的 AOP
• Spring AOP 仅支持方法级别的 Pointcuts  

























































